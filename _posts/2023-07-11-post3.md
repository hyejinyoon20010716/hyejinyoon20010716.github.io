---
layout: post
title: "[정보처리기사] 실기 개념정리 |  디자인 패턴"
date: 2023-07-11 14:00:23 +0900
categories: "Certificate"
---

출처 : 정보처리기사 실기 수제비 

# 디자인 패턴이란?


<br>

# 목적에 따른 디자인 패턴 유형 (생구행)
### (1) 생성패턴
### 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
<font style='color: blue; font-size: 20px; font-weight: bord;'>생 빌 프로 팩앱싱</font>   
- Builder(빌더)
  - 설명
- Prototype(프토로타입)
   - 설명   
- Factory Method(팩토리 메서드) 
   - 설명
- Abstract Factory(추상팩토리) 
   - 설명
- Siglton(싱글톤) 
  - 설명
   
<br>

### (2) 구조패턴
### 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
<font style='color: blue; font-size: 20px; font-weight: bord;'>구 브데 퍼플 프록 컴어</font>   
- Bridge(브릿지)
   - 설명
- Decorater(데코레이터) 
   - 설명
- Fercade(퍼사이드)
    - 설명
- Flyweight(플라이웨이트)
    - 설명
- Proxy(프록시) 
   - 설명
- Composite(컴포지트) 
   - 설명
- Adapter(어댑터)
   - 설명

<br>

### (3) 행위패턴
### 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴
<font style='color: blue; font-size: 20px; font-weight: bord; '>행 미인이 템옵 스테비커 스트매체</font>   
- Mediater(미디에이터)
   - 상호작용의 유연한 변경을 지원
   - 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져 느슨한 결합의 특성을 해칠 수 있기에 이를 해결하는 방법으로 중간에 통제와 지시를 할 수 있는 **중재자**를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄이는  패턴
- Interpreter(인터프리터)
   - 문법 자체를 캡슐화하여 사용
   - 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성해 여러 형태의 언어 구문을 해석할 수 있게 만드는 패턴
- Iterator(이터레이터)
    - 내부구조를 노출하지 않고, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 패턴
    - 컨렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 패턴
- Template Method(템플릿 메서드)
    - 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행 
    - 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
- Observer(옵저버)
    - 객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일다다 의존
    - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대다 의존성을 가지며 상호작용하는 객체 사이에는 가능한 느슨하게 결합하는 패턴 
- State(스테이트)
    - 객체의 상태에 따라 행위 내용을 변경
    - 객체 상태를 캡슐화해 클래스화함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시코드의 수정을 최소화할 수 있고, 유지보수 편의성도 갖는 패턴 
- Visitor(비지터)
    - 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위
    - 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 패턴
- Command(커맨드)
    - 요구사항을 객체로 캡슐화
    - 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴, 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 가짐
- Strategy(스트레이티지)
   - 행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환
   - 알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴
- Memento(메멘토)
    - 객체를 이전 상태로 복구시켜야 하는 경우, '작업취소(Undo)' 용청 가능
    - 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴, Undo 기능을 개발할 때 사용하는 패턴
- Chain of Responsivlity(체인 오브 리스폰서빌리티)
    - 한 요청을 2개 이상의 객체에서 처리
    - 정적으로 어떤 기능에 대한 처리의 연결이 하드 코딩되어 있을 때 기능 처리의 연결 변겅이 불가능한데, 이를 동적으로 연결된 경우에 따라 다르게 처리될 수 있도록 연결한 패턴

<br>

## 범위에 따른 디자인 패턴 유형 
### (1) 클래스
- 클래스 간 관련성(상속 관계를 다루는 패턴)
- 컴파일 타임에 정적으로 결정
  

### (2) 객체
- 객체 간 관련성을 다루는 패턴
- 런타임에 동적으로 결정