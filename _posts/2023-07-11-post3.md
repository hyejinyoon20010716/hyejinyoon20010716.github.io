---
layout: post
title: "[정보처리기사] 실기 개념정리 |  디자인 패턴"
date: 2023-07-11 14:00:23 +0900
categories: "Certificate"
---

출처 : 정보처리기사 실기 수제비 

# 디자인 패턴이란?
> 복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간, 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴
<br>

# 목적에 따른 디자인 패턴 유형 (생구행)
### (1) 생성패턴 - 5개
### 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
<font style='color: blue; font-family: Arial, sans-serif; font-size: 20px; font-weight: bord;'>생 빌 프로 팩앱싱</font>   
- Builder(빌더)
  - 생성과 표기를 분리해 복잡한 객체를 생성
  - 복잡한 인스턴스를 조립해 만드는 구조로, 복합 객체를 생성할 때 **객체를 생성하는 방법과 객체를 구현하는 방법을 분리**함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 패턴
- Prototype(프토로타입)
   - 기존 객체를 복제함으로써 객체를 생성
   - 일반적인 원형을 만들어 놓고, 그것을 **복사 후 필요한 부분만 수정해 사용**하는 패턴, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용
- Factory Method(팩토리 메서드) 
   - 생성할 객체의 클래스를 국한하지 않고 객체를 생성
   - 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식
- Abstract Factory(추상팩토리) 
   - 동일한 주제의 다른 팩토리를 묶음
   - 구체적인 클래스에 의존하지 않고 **서로 연관되거나 의존적인 객체들의 조합**을 만드는 인터페이스를 제공하는 패턴
- Siglton(싱글톤) 
  - **한 클래스에 한 객체만 존재**하도록 제한
  - 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체르 어디에서든지 참조할 수 있도록 하는 패턴
<br>

### (2) 구조패턴 - 7개
### 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
<font style='color: blue; font-size: font-family: Arial, sans-serif; 20px; font-weight: bord;'>구 브데 퍼플 프록 컴어</font>   
- Bridge(브릿지)
   - 구현뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우 활용
   - 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, **구현부에서 추상계층을 분리**해 추상화된 부분과 실제 구현 부분을 독집적으로 확장할 수 있는 패턴
- Decorater(데코레이터) 
   - 기존 객체의 합을 통해 기능을 동적으로 유연하게 확장
   - 기존에 구현되어 있는 클래스에 필요한 기능을 구현해나가는 패턴, 기능 확장이 필요할 때 객체 간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 **상속의 대안**으로 사용하는 패턴
- Fercade(퍼사이드)
    - 통합된 인터페이스 제공
    - 복잡한 시스템에 대해 **단순한 인터페이스**를 제공함으로써 사용자와 시스템 간 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽하는 패턴, 오류에 대해 단위별로 확인 가능, 사용자 측면에서 단순한 인터페이스 제공을 통해 접근성 향상
- Flyweight(플라이웨이트)
    - 여러 개의 ' 가상 인스턴스'를 제공해 메모리 절감
    - 다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스화하여 공유함으로써 메모리를 절약하고, **클래스의 경량화**를 목적으로 하는 패턴
- Proxy(프록시) 
   - 특정 개체로의 접근을 제어하기 위한 용도로 사용
   - **실체 객체에 대한 대리 객체**로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이점을 이용해 미리 할당하지 않아도 상과없은 것들을 실제 이용할 때 할당하게 해 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 해 **정보은닉** 역할도 수행하는 패턴
- Composite(컴포지트) 
   - 복합 객체와 단일 객체를 동일하게 취급
   - 객체들의 관계를 트리 구조로 구성해 **부분-전체 계층**을 표현하는 패턴, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴
- Adapter(어댑터)
   - 인터페이스가 호환되지 않는 클래스들을 함꼐 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움
   - 기존에 생성된 **클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할**을 하는 인터페이스를 만드는 패턴, 상속 이용 클래스 패턴과 위임 이용 인스턴스 패턴의 두 가지 형태로 사용 됨
<br>

### (3) 행위패턴 - 11개
### 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴
<font style='color: blue; font-size: 20px; font-family: Arial, sans-serif; font-weight: bord; '>행 미인이 템옵 스테비커 스트매체</font>   
- Mediater(미디에이터)
   - 상호작용의 유연한 변경을 지원
   - 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져 느슨한 결합의 특성을 해칠 수 있기에 이를 해결하는 방법으로 중간에 통제와 지시를 할 수 있는 **중재자**를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄이는  패턴
- Interpreter(인터프리터)
   - 문법 자체를 캡슐화하여 사용
   - 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성해 **여러 형태의 언어 구문을 해석할 수 있게** 만드는 패턴
- Iterator(이터레이터)
    - **내부구조 노출X**, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 패턴
    - 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 **모든 항목에 접근할 방법을 제공**하는 패턴
- Template Method(템플릿 메서드)
    - 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행 
    - 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 **특정 단계에서 수행하는 내역을 바꾸는** 패턴
- Observer(옵저버)
    - 객체의 상태 변화에 따라 다른 객체의 상태도 연동, **일다다 의존**
    - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대다 의존성을 가지며 상호작용하는 객체 사이에는 가능한 느슨하게 결합하는 패턴 
- State(스테이트)
    - 객체의 상태에 따라 행위 내용을 변경
    - **객체 상태를 캡슐화해 클래스화**함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시코드의 수정을 최소화할 수 있고, 유지보수 편의성도 갖는 패턴 
- Visitor(비지터)
    - 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위
    - 각 클래스 데이터 구조로부터 **처리 기능을 분리**하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 **기능만 따로 추가하거나 확장할 때** 사용하는 패턴
- Command(커맨드)
    - 요구사항을 객체로 캡슐화
    - **실행될 기능을 캡슐화**함으로써 주어진 여러 기능을 실행할 수 있는 **재사용성**이 높은 클래스를 설계하는 패턴, 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 가짐
- Strategy(스트레이티지)
   - **행위 객체를 클래스로 캡슐화**해 동적으로 행위를 자유롭게 변환
   - 알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴
- Memento(메멘토)
    - 객체를 이전 상태로 복구시켜야 하는 경우, '작업취소(Undo)' 용청 가능
    - 클래스 설계 관점에서 **객체의 정보를 저장**할 필요가 있을 때 적용하는 디자인 패턴, **Undo 기능을 개발할 때 사용**하는 패턴
- Chain of Responsivlity(체인 오브 리스폰서빌리티)
    - 한 요청을 2개 이상의 객체에서 처리
    - 정적으로 어떤 기능에 대한 처리의 연결이 하드 코딩되어 있을 때 기능 처리의 연결 변겅이 불가능한데, 이를 동적으로 연결된 경우에 따라 다르게 처리될 수 있도록 연결한 패턴
<br>

## 범위에 따른 디자인 패턴 유형 
### (1) 클래스
- 클래스 간 관련성(상속 관계를 다루는 패턴)
- 컴파일 타임에 정적으로 결정
  

### (2) 객체
- 객체 간 관련성을 다루는 패턴
- 런타임에 동적으로 결정